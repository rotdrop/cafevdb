/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 */
/**
 * Jquery integration plugin.
 *
 * @class tinymce.core.JqueryIntegration
 * @private
 */
!function(e){"function"==typeof define&&define.amd?
// AMD. Register as an anonymous module.
define(["jquery"],e):
// Browser globals
e(jQuery)}(function(e){var s,c,l,f=[],p="undefined"!=typeof global?global:window,d=e;function y(){
// Reference to tinymce needs to be lazily evaluated since tinymce
// might be loaded through the compressor or other means
return p.tinymce}console.info("TINYMCE JQUERY: ",d.fn.jquery),d.fn.tinymce=function(o){var e,n,i,t,u=this,r="";
// No match then just ignore the call
return u.length?
// Get editor instance
o?(u.css("visibility","hidden"),
// Load TinyMCE on demand, if we need to
p.tinymce||c||!(e=o.script_url)?
// Delay the init call until tinymce is loaded
1===c?f.push(a):a():(c=1,n=e.substring(0,e.lastIndexOf("/")),
// Check if it's a dev/src version they want to load then
// make sure that all plugins, themes etc are loaded in source mode as well
-1!=e.indexOf(".min")&&(r=".min"),
// Setup tinyMCEPreInit object this will later be used by the TinyMCE
// core script to locate other resources like CSS files, dialogs etc
// You can also predefined a tinyMCEPreInit object and then it will use that instead
p.tinymce=p.tinyMCEPreInit||{base:n,suffix:r},
// url contains gzip then we assume it's a compressor
-1!=e.indexOf("gzip")&&(i=o.language||"en",e=e+(/\?/.test(e)?"&":"?")+"js=true&core=true&suffix="+escape(r)+"&themes="+escape(o.theme||"modern")+"&plugins="+escape(o.plugins||"")+"&languages="+(i||""),
// Check if compressor script is already loaded otherwise setup a basic one
p.tinyMCE_GZ||(p.tinyMCE_GZ={start:function(){function t(e){y().ScriptLoader.markDone(y().baseURI.toAbsolute(e))}
// Add core languages
t("langs/"+i+".js"),
// Add themes with languages
t("themes/"+o.theme+"/theme"+r+".js"),t("themes/"+o.theme+"/langs/"+i+".js"),
// Add plugins with languages
d.each(o.plugins.split(","),function(e,n){n&&(t("plugins/"+n+"/plugin"+r+".js"),t("plugins/"+n+"/langs/"+i+".js"))})},end:function(){}})),(t=document.createElement("script")).type="text/javascript",t.onload=t.onreadystatechange=function(e){e=e||window.event,2===c||"load"!=e.type&&!/complete|loaded/.test(t.readyState)||(y().dom.Event.domLoaded=1,c=2,
// Execute callback after mainscript has been loaded and before the initialization occurs
o.script_loaded&&o.script_loaded(),a(),d.each(f,function(e,n){n()}))},t.src=e,document.body.appendChild(t)),u):y()?y().get(u[0].id):null:u;function a(){var a=[],c=0;
// Apply patches to the jQuery object, only once
l||(m(),l=!0),
// Create an editor instance for each matched node
u.each(function(e,n){var t,i=n.id,r=o.oninit;
// Generate unique id for target element if needed
i||(n.id=i=y().DOM.uniqueId()),
// Only init the editor once
y().get(i)||(
// Create editor instance and render it
t=y().createEditor(i,o),a.push(t),t.on("init",function(){var e,n=r;u.css("visibility",""),
// Run this if the oninit setting is defined
// this logic will fire the oninit callback ones each
// matched editor instance is initialized
r&&++c==a.length&&("string"==typeof n&&(e=-1===n.indexOf(".")?null:y().resolve(n.replace(/\.\w+$/,"")),n=y().resolve(n)),
// Call the oninit function with the object
n.apply(e||y(),a))}))}),
// Render the editor instances in a separate loop since we
// need to have the full editors array used in the onInit calls
d.each(a,function(e,n){n.render()})}},
// Add :tinymce pseudo selector this will select elements that has been converted into editor instances
// it's now possible to use things like $('*:tinymce') to get all TinyMCE bound elements.
d.extend(d.expr[":"],{tinymce:function(e){var n;return!!(e.id&&"tinymce"in p&&(n=y().get(e.id))&&n.editorManager===y())}});
// This function patches internal jQuery functions so that if
// you for example remove an div element containing an editor it's
// automatically destroyed by the TinyMCE API
var m=function(){function r(e){
// If the function is remove
"remove"===e&&this.each(function(e,n){var t=l(n);t&&t.remove()}),this.find("span.mceEditor,div.mceEditor").each(function(e,n){var t=y().get(n.id.replace(/_parent$/,""));t&&t.remove()})}function o(i){var e,n=this;
// Handle set value
/*jshint eqnull:true */if(null!=i)r.call(n),
// Saves the contents before get/set value of textarea/div
n.each(function(e,n){var t;(t=y().get(n.id))&&t.setContent(i)});else if(0<n.length&&(e=y().get(n[0].id)))return e.getContent()}function u(e){return e&&e.length&&p.tinymce&&e.is(":tinymce")}
// Removes any child editor instances by looking for editor wrapper elements
var l=function(e){var n=null;return e&&e.id&&p.tinymce?y().get(e.id):n},f={};
// Loads or saves contents from/to textarea if the value
// argument is defined it will set the TinyMCE internal contents
// Patch some setter/getter functions these will
// now be able to set/get the contents of editor instances for
// example $('#editorid').html('Content'); will update the TinyMCE iframe instance
d.each(["text","html","val"],function(e,n){var a=f[n]=d.fn[n],c="text"===n;d.fn[n]=function(e){var n=this;if(!u(n))return a.apply(n,arguments);if(e!==s)return o.call(n.filter(":tinymce"),e),a.apply(n.not(":tinymce"),arguments),n;// return original set for chaining
var i="",r=arguments;return(c?n:n.eq(0)).each(function(e,n){var t=l(n);i+=t?c?t.getContent().replace(/<(?:"[^"]*"|'[^']*'|[^'">])*>/g,""):t.getContent({save:!0}):a.apply(d(n),r)}),i}}),
// Makes it possible to use $('#id').append("content"); to append contents to the TinyMCE editor iframe
d.each(["append","prepend"],function(e,n){var t=f[n]=d.fn[n],r="prepend"===n;d.fn[n]=function(i){var e=this;return u(e)?i!==s?("string"==typeof i&&e.filter(":tinymce").each(function(e,n){var t=l(n);t&&t.setContent(r?i+t.getContent():t.getContent()+i)}),t.apply(e.not(":tinymce"),arguments),e):void 0:t.apply(e,arguments)}}),
// Makes sure that the editor instance gets properly destroyed when the parent element is removed
d.each(["remove","replaceWith","replaceAll","empty"],function(e,n){var t=f[n]=d.fn[n];d.fn[n]=function(){return r.call(this,n),t.apply(this,arguments)}}),f.attr=d.fn.attr,
// Makes sure that $('#tinymce_id').attr('value') gets the editors current HTML contents
d.fn.attr=function(e,n){var t=this,i=arguments;if(!e||"value"!==e||!u(t))return f.attr.apply(t,i);if(n!==s)return o.call(t.filter(":tinymce"),n),f.attr.apply(t.not(":tinymce"),i),t;// return original set for chaining
var r=t[0],a=l(r);return a?a.getContent({save:!0}):f.attr.apply(d(r),i)}}});